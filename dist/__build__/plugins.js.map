{"version":3,"sources":["webpack:///./src/scripts/colourPicker/colours.js"],"names":[],"mappings":";;;;;;;;;;;;;AAAA;AACA;;AAEA;AACA,YAAW,sCAAsC;AACjD,YAAW,sCAAsC;AACjD,YAAW,sCAAsC;AACjD,YAAW,sCAAsC;AACjD,YAAW,mDAAmD;AAC9D,YAAW,4CAA4C;AACvD,YAAW,sCAAsC;AACjD,YAAW,cAAc;AACzB,YAAW,mBAAmB;AAC9B,IAAG;;AAEH,iBAAgB;AAChB,eAAc;;AAEd;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,WAAU,sCAAsC;AAChD,gBAAe,gCAAgC;;AAE/C;AACA;;AAEA;AACA,mBAAkB;AAClB;AACA;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC;AACnC,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAoE;AACpE,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wDAAuD;AACvD,uBAAsB;AACtB;AACA,uEAAsE;AACtE,kDAAiD;AACjD;;AAEA,kDAAiD;AACjD,uBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,WAAW;AAC5B;AACA,oBAAmB;AACnB;;AAEA,2BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,6CAA4C;AAC5C;AACA;AACA,wDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uDAAsD;AACtD;AACA,gDAA+C;AAC/C;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAe;AACf,gBAAe;AACf;AACA;AACA;;AAEA,wCAAuC,iBAAiB;AACxD,wCAAuC,iBAAiB;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,mCAAmC;AACpD;;AAEA;AACA;AACA,6BAA4B;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAkC,iBAAiB;AACnD;AACA;;AAEA,mCAAkC,iBAAiB;AACnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0DAAyD;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0CAAyC,cAAc;AACvD;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,KAAK;AACxB,oCAAmC;AACnC;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA,2BAA0B;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH,sCAAqC;AACrC;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA,YAAW;AACX;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA,0CAAyC;;AAEzC;AACA,IAAG;;AAEH;AACA,4CAA2C;;AAE3C;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,gBAAe;AACf,qBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;;AAEA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA0B,KAAK;AAC/B;AACA;AACA;AACA;;AAEA;AACA,oBAAmB;AACnB;AACA;AACA,oDAAmD;;AAEnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,iDAAgD;AAChD;AACA;AACA,EAAC,U","file":"plugins.js","sourcesContent":["(function(window, undefined){\n\t\"use strict\"\n\n\tvar _valueRanges = {\n\t\t\trgb:   {r: [0, 255], g: [0, 255], b: [0, 255]},\n\t\t\thsv:   {h: [0, 360], s: [0, 100], v: [0, 100]},\n\t\t\thsl:   {h: [0, 360], s: [0, 100], l: [0, 100]},\n\t\t\tcmy:   {c: [0, 100], m: [0, 100], y: [0, 100]},\n\t\t\tcmyk:  {c: [0, 100], m: [0, 100], y: [0, 100], k: [0, 100]},\n\t\t\tLab:   {L: [0, 100], a: [-128, 127], b: [-128, 127]},\n\t\t\tXYZ:   {X: [0, 100], Y: [0, 100], Z: [0, 100]},\n\t\t\talpha: {alpha: [0, 1]},\n\t\t\tHEX:   {HEX: [0, 16777215]} // maybe we don't need this\n\t\t},\n\n\t\t_instance = {},\n\t\t_colors = {},\n\n\t\t// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html for more\n\t\tXYZMatrix = { // Observer = 2° (CIE 1931), Illuminant = D65 \n\t\t\tX: [ 0.4124564,  0.3575761,  0.1804375],\n\t\t\tY: [ 0.2126729,  0.7151522,  0.0721750],\n\t\t\tZ: [ 0.0193339,  0.1191920,  0.9503041],\n\t\t\tR: [ 3.2404542, -1.5371385, -0.4985314],\n\t\t\tG: [-0.9692660,  1.8760108,  0.0415560],\n\t\t\tB: [ 0.0556434, -0.2040259,  1.0572252]\n\t\t},\n\t\tgrey = {r: 0.298954, g: 0.586434, b: 0.114612}, // CIE-XYZ 1931\n\t\tluminance = {r: 0.2126, g: 0.7152, b: 0.0722}, // W3C 2.0\n\n\t\t_math = Math,\n\t\t_parseint = parseInt,\n\n\t\tColors = window.Colors = function(options) {\n\t\t\tthis.colors = {RND: {}};\n\t\t\tthis.options = {\n\t\t\t\tcolor: 'rgba(204, 82, 37, 0.8)', // init value(s)...\n\t\t\t\tXYZMatrix: XYZMatrix,\n\t\t\t\t// XYZReference: {},\n\t\t\t\tgrey: grey,\n\t\t\t\tluminance: luminance,\n\t\t\t\tvalueRanges: _valueRanges\n\t\t\t\t// customBG: '#808080'\n\t\t\t\t// convertCallback: undefined,\n\t\t\t\t// allMixDetails: false\n\t\t\t};\n\t\t\tinitInstance(this, options || {});\n\t\t},\n\t\tinitInstance = function(THIS, options) {\n\t\t\tvar matrix,\n\t\t\t\timportColor,\n\t\t\t\t_options = THIS.options,\n\t\t\t\tcustomBG;\n\n\t\t\tfocusInstance(THIS);\n\t\t\tfor (var option in options) {\n\t\t\t\tif (options[option] !== undefined) _options[option] = options[option];\n\t\t\t}\n\t\t\tmatrix = _options.XYZMatrix;\n\t\t\tif (!options.XYZReference) _options.XYZReference = {\n\t\t\t\tX: matrix.X[0] + matrix.X[1] + matrix.X[2],\n\t\t\t\tY: matrix.Y[0] + matrix.Y[1] + matrix.Y[2],\n\t\t\t\tZ: matrix.Z[0] + matrix.Z[1] + matrix.Z[2]\n\t\t\t};\n\t\t\tcustomBG = _options.customBG;\n\t\t\t_options.customBG = (typeof customBG === 'string') ? ColorConverter.txt2color(customBG).rgb : customBG;\n\t\t\t_colors = setColor(THIS.colors, _options.color, undefined, true); // THIS.colors = _colors = \n\t\t},\n\t\tfocusInstance = function(THIS) {\n\t\t\tif (_instance !== THIS) {\n\t\t\t\t_instance = THIS;\n\t\t\t\t_colors = THIS.colors;\n\t\t\t}\n\t\t};\n\n\tColors.prototype.setColor = function(newCol, type, alpha) {\n\t\tfocusInstance(this);\n\t\tif (newCol) {\n\t\t\treturn setColor(this.colors, newCol, type, undefined, alpha);\n\t\t} else {\n\t\t\tif (alpha !== undefined) {\n\t\t\t\tthis.colors.alpha = limitValue(alpha, 0, 1);\n\t\t\t}\n\t\t\treturn convertColors(type);\n\t\t}\n\t};\n\n\tColors.prototype.getColor = function(type) {\n\t\tvar result = this.colors, n = 0;\n\n\t\tif (type) {\n\t\t\ttype = type.split('.');\n\t\t\twhile (result[type[n]]) {\n\t\t\t\tresult = result[type[n++]];\n\t\t\t}\n\t\t\tif (type.length !== n) {\n\t\t\t\tresult = undefined;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\n\tColors.prototype.setCustomBackground = function(col) { // wild gues,... check again...\n\t\tfocusInstance(this); // needed???\n\t\tthis.options.customBG = (typeof col === 'string') ? ColorConverter.txt2color(col).rgb : col;\n\t\t// return setColor(this.colors, this.options.customBG, 'rgb', true); // !!!!RGB\n\t\treturn setColor(this.colors, undefined, 'rgb'); // just recalculate existing\n\t};\n\n\tColors.prototype.saveAsBackground = function() { // alpha\n\t\tfocusInstance(this); // needed???\n\t\t// return setColor(this.colors, this.colors.RND.rgb, 'rgb', true);\n\t\treturn setColor(this.colors, undefined, 'rgb', true);\n\t};\n\n\tColors.prototype.convertColor = function(color, type) {\n\t\tvar convert = ColorConverter,\n\t\t\tranges = _valueRanges,\n\t\t\ttypes = type.split('2'),\n\t\t\tfromType = types[0],\t\n\t\t\ttoType = types[1],\n\t\t\ttest = /(?:RG|HS|CM|LA)/,\n\t\t\tnormalizeFrom = test.test(fromType),\n\t\t\tnormalizeTo = test.test(toType),\n\t\t\texceptions = {LAB: 'Lab'},\n\t\t\tnormalize = function(color, type, reverse) {\n\t\t\t\tvar result = {},\n\t\t\t\t\tLab = type === 'Lab' ? 1 : 0;\n\n\t\t\t\tfor (var n in color) { // faster (but bigger) way: if/else outside 2 for loops\n\t\t\t\t\tresult[n] = reverse ?\n\t\t\t\t\t\t_math.round(color[n] * (Lab || ranges[type][n][1])) :\n\t\t\t\t\t\tcolor[n] / (Lab || ranges[type][n][1]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn result;\n\t\t\t};\n\n\t\tfromType = ranges[fromType] ? fromType : exceptions[fromType] || fromType.toLowerCase();\n\t\ttoType = ranges[toType] ? toType : exceptions[toType] || toType.toLowerCase();\n\n\t\tif (normalizeFrom && type !== 'RGB2HEX') { // from ABC to abc\n\t\t\tcolor = normalize(color, fromType);\n\t\t}\n\t\tcolor = fromType === toType ? color : ( // same type; returns same/normalized version\n\t\t\tconvert[fromType + '2' + toType] ? convert[fromType + '2' + toType](color, true) : // existing converter\n\t\t\ttoType === 'HEX' ? convert.RGB2HEX(type === 'RGB2HEX' ? color : normalize(fromType === 'rgb' ? color : \n\t\t\t\tconvert[fromType + '2rgb'](color, true), 'rgb', true)) :\n \t\t\tconvert['rgb2' + toType](convert[fromType + '2rgb'](color, true), true) // not in ColorConverter\n\t\t);\n\t\tif (normalizeTo) { // from abc to ABC\n\t\t\tcolor = normalize(color, toType, true);\n\t\t}\n\n\t\treturn color;\n\t};\n\n\t// ------------------------------------------------------ //\n\t// ---------- Color calculation related stuff  ---------- //\n\t// -------------------------------------------------------//\n\n\tfunction setColor(colors, color, type, save, alpha) { // color only full range\n\t\tif (typeof color === 'string') {\n\t\t\tvar color = ColorConverter.txt2color(color); // new object\n\t\t\ttype = color.type;\n\t\t\t_colors[type] = color[type];\n\t\t\talpha = alpha !== undefined ? alpha : color.alpha;\n\t\t} else if (color) {\n\t\t\tfor (var n in color) {\n\t\t\t\tcolors[type][n] = limitValue(color[n] / _valueRanges[type][n][1], 0 , 1);\n\t\t\t}\n\t\t}\n\t\tif (alpha !== undefined) {\n\t\t\tcolors.alpha = limitValue(+alpha, 0, 1);\n\t\t}\n\t\treturn convertColors(type, save ? colors : undefined);\n\t}\n\n\tfunction saveAsBackground(RGB, rgb, alpha) {\n\t\tvar grey = _instance.options.grey,\n\t\t\tcolor = {};\n\n\t\tcolor.RGB = {r: RGB.r, g: RGB.g, b: RGB.b};\n\t\tcolor.rgb = {r: rgb.r, g: rgb.g, b: rgb.b};\n\t\tcolor.alpha = alpha;\n\t\t// color.RGBLuminance = getLuminance(RGB);\n\t\tcolor.equivalentGrey = _math.round(grey.r * RGB.r + grey.g * RGB.g + grey.b * RGB.b);\n\n\t\tcolor.rgbaMixBlack = mixColors(rgb, {r: 0, g: 0, b: 0}, alpha, 1);\n\t\tcolor.rgbaMixWhite = mixColors(rgb, {r: 1, g: 1, b: 1}, alpha, 1);\n\t\tcolor.rgbaMixBlack.luminance = getLuminance(color.rgbaMixBlack, true);\n\t\tcolor.rgbaMixWhite.luminance = getLuminance(color.rgbaMixWhite, true);\n\n\t\tif (_instance.options.customBG) {\n\t\t\tcolor.rgbaMixCustom = mixColors(rgb, _instance.options.customBG, alpha, 1);\n\t\t\tcolor.rgbaMixCustom.luminance = getLuminance(color.rgbaMixCustom, true);\n\t\t\t_instance.options.customBG.luminance = getLuminance(_instance.options.customBG, true);\n\t\t}\n\n\t\treturn color;\n\t}\n\n\tfunction convertColors(type, colorObj) {\n\t\t// console.time('convertColors');\n\t\tvar _Math = _math,\n\t\t\tcolors = colorObj || _colors,\n\t\t\tconvert = ColorConverter,\n\t\t\toptions = _instance.options,\n\t\t\tranges = _valueRanges,\n\t\t\tRND = colors.RND,\n\t\t\t// type = colorType, // || _mode.type,\n\t\t\tmodes, mode = '', from = '', // value = '',\n\t\t\texceptions = {hsl: 'hsv', cmyk: 'cmy', rgb: type},\n\t\t\tRGB = RND.rgb, SAVE, SMART;\n\n\t\tif (type !== 'alpha') {\n\t\t\tfor (var typ in ranges) {\n\t\t\t\tif (!ranges[typ][typ]) { // no alpha|HEX\n\t\t\t\t\tif (type !== typ && typ !== 'XYZ') {\n\t\t\t\t\t\tfrom = exceptions[typ] || 'rgb';\n\t\t\t\t\t\tcolors[typ] = convert[from + '2' + typ](colors[from]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!RND[typ]) RND[typ] = {};\n\t\t\t\t\tmodes = colors[typ];\n\t\t\t\t\tfor(mode in modes) {\n\t\t\t\t\t\tRND[typ][mode] = _Math.round(modes[mode] * (typ === 'Lab' ? 1 : ranges[typ][mode][1]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (type !== 'Lab') {\n\t\t\t\tdelete colors._rgb;\n\t\t\t}\n\n\t\t\tRGB = RND.rgb;\n\t\t\tcolors.HEX = convert.RGB2HEX(RGB);\n\t\t\tcolors.equivalentGrey =\n\t\t\t\toptions.grey.r * colors.rgb.r +\n\t\t\t\toptions.grey.g * colors.rgb.g +\n\t\t\t\toptions.grey.b * colors.rgb.b;\n\t\t\tcolors.webSave = SAVE = getClosestWebColor(RGB, 51);\n\t\t\t// colors.webSave.HEX = convert.RGB2HEX(colors.webSave);\n\t\t\tcolors.webSmart = SMART = getClosestWebColor(RGB, 17);\n\t\t\t// colors.webSmart.HEX = convert.RGB2HEX(colors.webSmart);\n\t\t\tcolors.saveColor =\n\t\t\t\tRGB.r === SAVE.r && RGB.g === SAVE.g && RGB.b === SAVE.b  ? 'web save' :\n\t\t\t\tRGB.r === SMART.r && RGB.g === SMART.g && RGB.b === SMART.b  ? 'web smart' : '';\n\t\t\tcolors.hueRGB = convert.hue2RGB(colors.hsv.h);\n\n\t\t\tif (colorObj) {\n\t\t\t\tcolors.background = saveAsBackground(RGB, colors.rgb, colors.alpha);\n\t\t\t}\n\t\t} // else RGB = RND.rgb;\n\n\t\tvar rgb = colors.rgb, // for better minification...\n\t\t\talpha = colors.alpha,\n\t\t\tluminance = 'luminance',\n\t\t\tbackground = colors.background,\n\t\t\trgbaMixBlack, rgbaMixWhite, rgbaMixCustom, \n\t\t\trgbaMixBG, rgbaMixBGMixBlack, rgbaMixBGMixWhite, rgbaMixBGMixCustom,\n\t\t\t_mixColors = mixColors,\n\t\t\t_getLuminance = getLuminance,\n\t\t\t_getWCAG2Ratio = getWCAG2Ratio,\n\t\t\t_getHueDelta = getHueDelta;\n\n\t\trgbaMixBlack = _mixColors(rgb, {r: 0, g: 0, b: 0}, alpha, 1);\n\t\trgbaMixBlack[luminance] = _getLuminance(rgbaMixBlack, true);\n\t\tcolors.rgbaMixBlack = rgbaMixBlack;\n\n\t\trgbaMixWhite = _mixColors(rgb, {r: 1, g: 1, b: 1}, alpha, 1);\n\t\trgbaMixWhite[luminance] = _getLuminance(rgbaMixWhite, true);\n\t\tcolors.rgbaMixWhite = rgbaMixWhite;\n\n\t\tif (options.allMixDetails) {\n\t\t\trgbaMixBlack.WCAG2Ratio = _getWCAG2Ratio(rgbaMixBlack[luminance], 0);\n\t\t\trgbaMixWhite.WCAG2Ratio = _getWCAG2Ratio(rgbaMixWhite[luminance], 1);\n\n\t\t\tif (options.customBG) {\n\t\t\t\trgbaMixCustom = _mixColors(rgb, options.customBG, alpha, 1);\n\t\t\t\trgbaMixCustom[luminance] = _getLuminance(rgbaMixCustom, true);\n\t\t\t\trgbaMixCustom.WCAG2Ratio = _getWCAG2Ratio(rgbaMixCustom[luminance], options.customBG[luminance]);\n\t\t\t\tcolors.rgbaMixCustom = rgbaMixCustom;\n\t\t\t}\n\n\t\t\trgbaMixBG = _mixColors(rgb, background.rgb, alpha, background.alpha);\n\t\t\trgbaMixBG[luminance] = _getLuminance(rgbaMixBG, true); // ?? do we need this?\n\t\t\tcolors.rgbaMixBG = rgbaMixBG;\n\n\t\t\trgbaMixBGMixBlack = _mixColors(rgb, background.rgbaMixBlack, alpha, 1);\n\t\t\trgbaMixBGMixBlack[luminance] = _getLuminance(rgbaMixBGMixBlack, true);\n\t\t\trgbaMixBGMixBlack.WCAG2Ratio = _getWCAG2Ratio(rgbaMixBGMixBlack[luminance],\n\t\t\t\tbackground.rgbaMixBlack[luminance]);\n\t\t\t/* ------ */\n\t\t\trgbaMixBGMixBlack.luminanceDelta = _Math.abs(\n\t\t\t\trgbaMixBGMixBlack[luminance] - background.rgbaMixBlack[luminance]);\n\t\t\trgbaMixBGMixBlack.hueDelta = _getHueDelta(background.rgbaMixBlack, rgbaMixBGMixBlack, true);\n\t\t\t/* ------ */\n\t\t\tcolors.rgbaMixBGMixBlack = rgbaMixBGMixBlack;\n\n\t\t\trgbaMixBGMixWhite = _mixColors(rgb, background.rgbaMixWhite, alpha, 1);\n\t\t\trgbaMixBGMixWhite[luminance] = _getLuminance(rgbaMixBGMixWhite, true);\n\t\t\trgbaMixBGMixWhite.WCAG2Ratio = _getWCAG2Ratio(rgbaMixBGMixWhite[luminance],\n\t\t\t\tbackground.rgbaMixWhite[luminance]);\n\t\t\t/* ------ */\n\t\t\trgbaMixBGMixWhite.luminanceDelta = _Math.abs(\n\t\t\t\trgbaMixBGMixWhite[luminance] - background.rgbaMixWhite[luminance]);\n\t\t\trgbaMixBGMixWhite.hueDelta = _getHueDelta(background.rgbaMixWhite, rgbaMixBGMixWhite, true);\n\t\t\t/* ------ */\n\t\t\tcolors.rgbaMixBGMixWhite = rgbaMixBGMixWhite;\n\t\t}\n\n\t\tif (options.customBG) {\n\t\t\trgbaMixBGMixCustom = _mixColors(rgb, background.rgbaMixCustom, alpha, 1);\n\t\t\trgbaMixBGMixCustom[luminance] = _getLuminance(rgbaMixBGMixCustom, true);\n\t\t\trgbaMixBGMixCustom.WCAG2Ratio = _getWCAG2Ratio(rgbaMixBGMixCustom[luminance],\n\t\t\t\tbackground.rgbaMixCustom[luminance]);\n\t\t\tcolors.rgbaMixBGMixCustom = rgbaMixBGMixCustom;\n\t\t\t/* ------ */\n\t\t\trgbaMixBGMixCustom.luminanceDelta = _Math.abs(\n\t\t\t\trgbaMixBGMixCustom[luminance] - background.rgbaMixCustom[luminance]);\n\t\t\trgbaMixBGMixCustom.hueDelta = _getHueDelta(background.rgbaMixCustom, rgbaMixBGMixCustom, true);\n\t\t\t/* ------ */\n\t\t}\n\n\t\tcolors.RGBLuminance = _getLuminance(RGB);\n\t\tcolors.HUELuminance = _getLuminance(colors.hueRGB);\n\n\t\t// renderVars.readyToRender = true;\n\t\tif (options.convertCallback) {\n\t\t\toptions.convertCallback(colors, type); //, convert); //, _mode);\n\t\t}\n\n\t\t// console.timeEnd('convertColors')\n\t\t// if (colorObj)\n\t\treturn colors;\n\t}\n\n\n\t// ------------------------------------------------------ //\n\t// ------------------ color conversion ------------------ //\n\t// -------------------------------------------------------//\n\n\tvar ColorConverter = {\n\t\ttxt2color: function(txt) {\n\t\t\tvar color = {},\n\t\t\t\tparts = txt.replace(/(?:#|\\)|%)/g, '').split('('),\n\t\t\t\tvalues = (parts[1] || '').split(/,\\s*/),\n\t\t\t\ttype = parts[1] ? parts[0].substr(0, 3) : 'rgb',\n\t\t\t\tm = '';\n\n\t\t\tcolor.type = type;\n\t\t\tcolor[type] = {};\n\t\t\tif (parts[1]) {\n\t\t\t\tfor (var n = 3; n--; ) {\n\t\t\t\t\tm = type[n] || type.charAt(n); // IE7\n\t\t\t\t\tcolor[type][m] = +values[n] / _valueRanges[type][m][1];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcolor.rgb = ColorConverter.HEX2rgb(parts[0]);\n\t\t\t}\n\t\t\t// color.color = color[type];\n\t\t\tcolor.alpha = values[3] ? +values[3] : 1;\n\n\t\t\treturn color;\n\t\t},\n\n\t\tRGB2HEX: function(RGB) {\n\t\t\treturn (\n\t\t\t\t(RGB.r < 16 ? '0' : '') + RGB.r.toString(16) +\n\t\t\t\t(RGB.g < 16 ? '0' : '') + RGB.g.toString(16) +\n\t\t\t\t(RGB.b < 16 ? '0' : '') + RGB.b.toString(16)\n\t\t\t).toUpperCase();\n\t\t},\n\n\t\tHEX2rgb: function(HEX) {\n\t\t\tvar _parseInt = _parseint;\n\n\t\t\tHEX = HEX.split(''); // IE7\n\t\t\treturn {\n\t\t\t\tr: _parseInt(HEX[0] + HEX[HEX[3] ? 1 : 0], 16) / 255,\n\t\t\t\tg: _parseInt(HEX[HEX[3] ? 2 : 1] + (HEX[3] || HEX[1]), 16) / 255,\n\t\t\t\tb: _parseInt((HEX[4] || HEX[2]) + (HEX[5] || HEX[2]), 16) / 255\n\t\t\t};\n\t\t},\n\n\t\thue2RGB: function(hue) {\n\t\t\tvar _Math = _math,\n\t\t\t\th = hue * 6,\n\t\t\t\tmod = ~~h % 6, // Math.floor(h) -> faster in most browsers\n\t\t\t\ti = h === 6 ? 0 : (h - mod);\n\n\t\t\treturn {\n\t\t\t\tr: _Math.round([1, 1 - i, 0, 0, i, 1][mod] * 255),\n\t\t\t\tg: _Math.round([i, 1, 1, 1 - i, 0, 0][mod] * 255),\n\t\t\t\tb: _Math.round([0, 0, i, 1, 1, 1 - i][mod] * 255)\n\t\t\t};\n\t\t},\n\n\t\t// ------------------------ HSV ------------------------ //\n\n\t\trgb2hsv: function(rgb) { // faster\n\t\t\tvar _Math = _math,\n\t\t\t\tr = rgb.r,\n\t\t\t\tg = rgb.g,\n\t\t\t\tb = rgb.b,\n\t\t\t\tk = 0, chroma, min, s;\n\n\t\t\tif (g < b) {\n\t\t\t\tg = b + (b = g, 0);\n\t\t\t\tk = -1;\n\t\t\t}\n\t\t\tmin = b;\n\t\t\tif (r < g) {\n\t\t\t\tr = g + (g = r, 0);\n\t\t\t\tk = -2 / 6 - k;\n\t\t\t\tmin = _Math.min(g, b); // g < b ? g : b; ???\n\t\t\t}\n\t\t\tchroma = r - min;\n\t\t\ts = r ? (chroma / r) : 0;\n\t\t\treturn {\n\t\t\t\th: s < 1e-15 ? ((_colors && _colors.hsl && _colors.hsl.h) || 0) :\n\t\t\t\t\tchroma ? _Math.abs(k + (g - b) / (6 * chroma)) : 0,\n\t\t\t\ts: r ? (chroma / r) : ((_colors && _colors.hsv && _colors.hsv.s) || 0), // ??_colors.hsv.s || 0\n\t\t\t\tv: r\n\t\t\t};\n\t\t},\n\n\t\thsv2rgb: function(hsv) {\n\t\t\tvar h = hsv.h * 6,\n\t\t\t\ts = hsv.s,\n\t\t\t\tv = hsv.v,\n\t\t\t\ti = ~~h, // Math.floor(h) -> faster in most browsers\n\t\t\t\tf = h - i,\n\t\t\t\tp = v * (1 - s),\n\t\t\t\tq = v * (1 - f * s),\n\t\t\t\tt = v * (1 - (1 - f) * s),\n\t\t\t\tmod = i % 6;\n\n\t\t\treturn {\n\t\t\t\tr: [v, q, p, p, t, v][mod],\n\t\t\t\tg: [t, v, v, q, p, p][mod],\n\t\t\t\tb: [p, p, t, v, v, q][mod]\n\t\t\t};\n\t\t},\n\n\t\t// ------------------------ HSL ------------------------ //\n\n\t\thsv2hsl: function(hsv) {\n\t\t\tvar l = (2 - hsv.s) * hsv.v,\n\t\t\t\ts = hsv.s * hsv.v;\n\n\t\t\ts = !hsv.s ? 0 : l < 1 ? (l ? s / l : 0) : s / (2 - l);\n\n\t\t\treturn {\n\t\t\t\th: hsv.h,\n\t\t\t\ts: !hsv.v && !s ? ((_colors && _colors.hsl && _colors.hsl.s) || 0) : s, // ???\n\t\t\t\tl: l / 2\n\t\t\t};\n\t\t},\n\n\t\trgb2hsl: function(rgb, dependent) { // not used in Color\n\t\t\tvar hsv = ColorConverter.rgb2hsv(rgb);\n\n\t\t\treturn ColorConverter.hsv2hsl(dependent ? hsv : (_colors.hsv = hsv));\n\t\t},\n\n\t\thsl2rgb: function(hsl) {\n\t\t\tvar h = hsl.h * 6,\n\t\t\t\ts = hsl.s,\n\t\t\t\tl = hsl.l,\n\t\t\t\tv = l < 0.5 ? l * (1 + s) : (l + s) - (s * l),\n\t\t\t\tm = l + l - v,\n\t\t\t\tsv = v ? ((v - m) / v) : 0,\n\t\t\t\tsextant = ~~h, // Math.floor(h) -> faster in most browsers\n\t\t\t\tfract = h - sextant,\n\t\t\t\tvsf = v * sv * fract,\n\t\t\t\tt = m + vsf,\n\t\t\t\tq = v - vsf,\n\t\t\t\tmod = sextant % 6;\n\n\t\t\treturn {\n\t\t\t\tr: [v, q, m, m, t, v][mod],\n\t\t\t\tg: [t, v, v, q, m, m][mod],\n\t\t\t\tb: [m, m, t, v, v, q][mod]\n\t\t\t};\n\t\t},\n\n\t\t// ------------------------ CMYK ------------------------ //\n\t\t// Quote from Wikipedia:\n\t\t// \"Since RGB and CMYK spaces are both device-dependent spaces, there is no \n\t\t// simple or general conversion formula that converts between them.  \n\t\t// Conversions are generally done through color management systems, using \n\t\t// color profiles that describe the spaces being converted. Nevertheless, the \n\t\t// conversions cannot be exact, since these spaces have very different gamuts.\"\n\t\t// Translation: the following are just simple RGB to CMY(K) and visa versa conversion functions.\n\n\t\trgb2cmy: function(rgb) {\n\t\t\treturn {\n\t\t\t\tc: 1 - rgb.r,\n\t\t\t\tm: 1 - rgb.g,\n\t\t\t\ty: 1 - rgb.b\n\t\t\t};\n\t\t},\n\n\t\tcmy2cmyk: function(cmy) {\n\t\t\tvar _Math = _math,\n\t\t\t\tk = _Math.min(_Math.min(cmy.c, cmy.m), cmy.y),\n\t\t\t\tt = 1 - k || 1e-20;\n\n\t\t\treturn { // regular\n\t\t\t\tc: (cmy.c - k) / t,\n\t\t\t\tm: (cmy.m - k) / t,\n\t\t\t\ty: (cmy.y - k) / t,\n\t\t\t\tk: k\n\t\t\t};\n\t\t},\n\n\t\tcmyk2cmy: function(cmyk) {\n\t\t\tvar k = cmyk.k;\n\n\t\t\treturn { // regular\n\t\t\t\tc: cmyk.c * (1 - k) + k,\n\t\t\t\tm: cmyk.m * (1 - k) + k,\n\t\t\t\ty: cmyk.y * (1 - k) + k\n\t\t\t};\n\t\t},\n\n\t\tcmy2rgb: function(cmy) {\n\t\t\treturn {\n\t\t\t\tr: 1 - cmy.c,\n\t\t\t\tg: 1 - cmy.m,\n\t\t\t\tb: 1 - cmy.y\n\t\t\t};\n\t\t},\n\n\t\trgb2cmyk: function(rgb, dependent) {\n\t\t\tvar cmy = ColorConverter.rgb2cmy(rgb); // doppelt??\n\n\t\t\treturn ColorConverter.cmy2cmyk(dependent ? cmy : (_colors.cmy = cmy));\n\t\t},\n\n\t\tcmyk2rgb: function(cmyk, dependent) {\n\t\t\tvar cmy = ColorConverter.cmyk2cmy(cmyk); // doppelt??\n\n\t\t\treturn ColorConverter.cmy2rgb(dependent ? cmy : (_colors.cmy = cmy));\n\t\t},\n\n\t\t// ------------------------ LAB ------------------------ //\n\n\t\tXYZ2rgb: function(XYZ, skip) {\n\t\t\tvar _Math = _math,\n\t\t\t\tM = _instance.options.XYZMatrix,\n\t\t\t\tX = XYZ.X,\n\t\t\t\tY = XYZ.Y,\n\t\t\t\tZ = XYZ.Z,\n\t\t\t\tr = X * M.R[0] + Y * M.R[1] + Z * M.R[2],\n\t\t\t\tg = X * M.G[0] + Y * M.G[1] + Z * M.G[2],\n\t\t\t\tb = X * M.B[0] + Y * M.B[1] + Z * M.B[2],\n\t\t\t\tN = 1 / 2.4;\n\n\t\t\tM = 0.0031308;\n\n\t\t\tr = (r > M ? 1.055 * _Math.pow(r, N) - 0.055 : 12.92 * r);\n\t\t\tg = (g > M ? 1.055 * _Math.pow(g, N) - 0.055 : 12.92 * g);\n\t\t\tb = (b > M ? 1.055 * _Math.pow(b, N) - 0.055 : 12.92 * b);\n\n\t\t\tif (!skip) { // out of gammut\n\t\t\t\t_colors._rgb = {r: r, g: g, b: b};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tr: limitValue(r, 0, 1),\n\t\t\t\tg: limitValue(g, 0, 1),\n\t\t\t\tb: limitValue(b, 0, 1)\n\t\t\t};\n\t\t},\n\n\t\trgb2XYZ: function(rgb) {\n\t\t\tvar _Math = _math,\n\t\t\t\tM = _instance.options.XYZMatrix,\n\t\t\t\tr = rgb.r,\n\t\t\t\tg = rgb.g,\n\t\t\t\tb = rgb.b,\n\t\t\t\tN = 0.04045;\n\n\t\t\tr = (r > N ? _Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92);\n\t\t\tg = (g > N ? _Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92);\n\t\t\tb = (b > N ? _Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92);\n\n\t\t\treturn {\n\t\t\t\tX: r * M.X[0] + g * M.X[1] + b * M.X[2],\n\t\t\t\tY: r * M.Y[0] + g * M.Y[1] + b * M.Y[2],\n\t\t\t\tZ: r * M.Z[0] + g * M.Z[1] + b * M.Z[2]\n\t\t\t};\n\t\t},\n\n\t\tXYZ2Lab: function(XYZ) {\n\t\t\tvar _Math = _math,\n\t\t\t\tR = _instance.options.XYZReference,\n\t\t\t\tX = XYZ.X / R.X,\n\t\t\t\tY = XYZ.Y / R.Y,\n\t\t\t\tZ = XYZ.Z / R.Z,\n\t\t\t\tN = 16 / 116, M = 1 / 3, K = 0.008856, L = 7.787037;\n\n\t\t\tX = X > K ? _Math.pow(X, M) : (L * X) + N;\n\t\t\tY = Y > K ? _Math.pow(Y, M) : (L * Y) + N;\n\t\t\tZ = Z > K ? _Math.pow(Z, M) : (L * Z) + N;\n\n\t\t\treturn {\n\t\t\t\tL: (116 * Y) - 16,\n\t\t\t\ta: 500 * (X - Y),\n\t\t\t\tb: 200 * (Y - Z)\n\t\t\t};\n\t\t},\n\n\t\tLab2XYZ: function(Lab) {\n\t\t\tvar _Math = _math,\n\t\t\t\tR = _instance.options.XYZReference,\n\t\t\t\tY = (Lab.L + 16) / 116,\n\t\t\t\tX = Lab.a / 500 + Y,\n\t\t\t\tZ = Y - Lab.b / 200,\n\t\t\t\tX3 = _Math.pow(X, 3),\n\t\t\t\tY3 = _Math.pow(Y, 3),\n\t\t\t\tZ3 = _Math.pow(Z, 3),\n\t\t\t\tN = 16 / 116, K = 0.008856, L = 7.787037;\n\n\t\t\treturn {\n\t\t\t\tX: (X3 > K ? X3 : (X - N) / L) * R.X,\n\t\t\t\tY: (Y3 > K ? Y3 : (Y - N) / L) * R.Y,\n\t\t\t\tZ: (Z3 > K ? Z3 : (Z - N) / L) * R.Z\n\t\t\t};\n\t\t},\n\n\t\trgb2Lab: function(rgb, dependent) {\n\t\t\tvar XYZ = ColorConverter.rgb2XYZ(rgb);\n\n\t\t\treturn ColorConverter.XYZ2Lab(dependent ? XYZ : (_colors.XYZ = XYZ));\n\t\t},\n\n\t\tLab2rgb: function(Lab, dependent) {\n\t\t\tvar XYZ = ColorConverter.Lab2XYZ(Lab);\n\n\t\t\treturn ColorConverter.XYZ2rgb(dependent ? XYZ : (_colors.XYZ = XYZ), dependent);\n\t\t}\n\t};\n\n\t// ------------------------------------------------------ //\n\t// ------------------ helper functions ------------------ //\n\t// -------------------------------------------------------//\n\n\tfunction getClosestWebColor(RGB, val) {\n\t\tvar out = {},\n\t\t\ttmp = 0,\n\t\t\thalf = val / 2;\n\n\t\tfor (var n in RGB) {\n\t\t\ttmp = RGB[n] % val; // 51 = 'web save', 17 = 'web smart'\n\t\t\tout[n] = RGB[n] + (tmp > half ? val - tmp : -tmp);\n\t\t}\n\t\treturn out;\n\t}\n\n\tfunction getHueDelta(rgb1, rgb2, nominal) {\n\t\tvar _Math = _math;\n\n\t\treturn (_Math.max(rgb1.r - rgb2.r, rgb2.r - rgb1.r) +\n\t\t\t\t_Math.max(rgb1.g - rgb2.g, rgb2.g - rgb1.g) +\n\t\t\t\t_Math.max(rgb1.b - rgb2.b, rgb2.b - rgb1.b)) * (nominal ? 255 : 1) / 765;\n\t}\n\n\tfunction getLuminance(rgb, normalized) {\n\t\tvar div = normalized ? 1 : 255,\n\t\t\tRGB = [rgb.r / div, rgb.g / div, rgb.b / div],\n\t\t\tluminance = _instance.options.luminance;\n\n\t\tfor (var i = RGB.length; i--; ) {\n\t\t\tRGB[i] = RGB[i] <= 0.03928 ? RGB[i] / 12.92 : _math.pow(((RGB[i] + 0.055) / 1.055), 2.4);\n\t\t}\n\t\treturn ((luminance.r * RGB[0]) + (luminance.g * RGB[1]) + (luminance.b * RGB[2]));\n\t}\n\n\tfunction mixColors(topColor, bottomColor, topAlpha, bottomAlpha) {\n\t\tvar newColor = {},\n\t\t\talphaTop = (topAlpha !== undefined ? topAlpha : 1),\n\t\t\talphaBottom = (bottomAlpha !== undefined ? bottomAlpha : 1),\n\t\t\talpha = alphaTop + alphaBottom * (1 - alphaTop); // 1 - (1 - alphaTop) * (1 - alphaBottom);\n\n\t\tfor(var n in topColor) {\n\t\t\tnewColor[n] = (topColor[n] * alphaTop + bottomColor[n] * alphaBottom * (1 - alphaTop)) / alpha;\n\t\t}\n\t\tnewColor.a = alpha;\n\t\treturn newColor;\n\t}\n\n\tfunction getWCAG2Ratio(lum1, lum2) {\n\t\tvar ratio = 1;\n\n\t\tif (lum1 >= lum2) {\n\t\t\tratio = (lum1 + 0.05) / (lum2 + 0.05);\n\t\t} else {\n\t\t\tratio = (lum2 + 0.05) / (lum1 + 0.05);\n\t\t}\n\t\treturn _math.round(ratio * 100) / 100;\n\t}\n\n\tfunction limitValue(value, min, max) {\n\t\t// return Math.max(min, Math.min(max, value)); // faster??\n\t\treturn (value > max ? max : value < min ? min : value);\n\t}\n})(window);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/scripts/colourPicker/colours.js\n ** module id = 718\n ** module chunks = 4\n **/"],"sourceRoot":""}